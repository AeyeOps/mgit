name: Enhanced Release with Full Context

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., v0.2.4)'
        required: true
        type: string
      release_type:
        description: 'Type of release'
        required: true
        type: choice
        options: ['feature', 'bugfix', 'maintenance']
        default: 'feature'

jobs:
  generate-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: read
      
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          
      - name: Generate Codebase Context
        run: |
          # Create a structured overview of the codebase
          cat > generate_context.py << 'EOF'
          import os
          import ast
          import json
          from pathlib import Path
          
          def extract_docstrings(filepath):
              """Extract module, class, and function docstrings."""
              try:
                  with open(filepath, 'r') as f:
                      tree = ast.parse(f.read())
                  
                  docstrings = []
                  
                  # Module docstring
                  if ast.get_docstring(tree):
                      docstrings.append(f"Module: {ast.get_docstring(tree)[:200]}...")
                  
                  # Class and function docstrings
                  for node in ast.walk(tree):
                      if isinstance(node, (ast.ClassDef, ast.FunctionDef)):
                          docstring = ast.get_docstring(node)
                          if docstring:
                              docstrings.append(f"{node.name}: {docstring[:100]}...")
                              
                  return docstrings
              except:
                  return []
          
          # Generate context document
          context = []
          
          # 1. Project Overview from README
          context.append("# mgit Project Overview\n")
          with open('README.md', 'r') as f:
              lines = f.readlines()
              for i, line in enumerate(lines[:50]):  # First 50 lines
                  if line.startswith('#'):
                      context.append(line)
                  elif 'clone' in line.lower() or 'pull' in line.lower() or 'repository' in line.lower():
                      context.append(line)
          
          # 2. Architecture Overview
          context.append("\n## Architecture\n")
          context.append("```")
          os.system("tree -I '__pycache__|*.pyc|.git|dist|build' --dirsfirst -L 3 mgit/ > tree.txt")
          with open('tree.txt', 'r') as f:
              context.append(f.read())
          context.append("```\n")
          
          # 3. Key Module Documentation
          context.append("\n## Key Modules and Their Purpose\n")
          
          key_files = [
              'mgit/__init__.py',
              'mgit/providers/base.py',
              'mgit/commands/listing.py',
              'mgit/config/yaml_manager.py',
              'mgit/providers/manager_v2.py'
          ]
          
          for filepath in key_files:
              if Path(filepath).exists():
                  context.append(f"\n### {filepath}\n")
                  docstrings = extract_docstrings(filepath)
                  for doc in docstrings[:5]:  # First 5 docstrings
                      context.append(f"- {doc}\n")
          
          # 4. Current Features List
          context.append("\n## Current Features\n")
          context.append("- Multi-provider support: Azure DevOps, GitHub, BitBucket\n")
          context.append("- Repository discovery with query patterns\n")
          context.append("- Bulk clone and pull operations\n")
          context.append("- YAML-based configuration management\n")
          context.append("- Progress tracking for operations\n")
          
          # Save context
          with open('codebase-context.md', 'w') as f:
              f.writelines(context)
              
          print(f"Generated context document with {len(context)} lines")
          EOF
          
          python generate_context.py
          
      - name: Analyze Changes with PR Context
        id: analyze-changes
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ github.event.inputs.version }}"
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          
          # Get last release tag
          LAST_TAG=$(git describe --tags --abbrev=0 HEAD~1 2>/dev/null || echo "")
          echo "last_tag=${LAST_TAG}" >> $GITHUB_OUTPUT
          
          # Create comprehensive change analysis
          cat > analyze_changes.py << 'EOF'
          import subprocess
          import json
          import re
          
          last_tag = "$LAST_TAG"
          
          # 1. Get merged PRs with full context
          pr_data = subprocess.run([
              "gh", "pr", "list", 
              "--state", "merged", 
              "--base", "main", 
              "--limit", "20",
              "--json", "number,title,body,author,files,labels"
          ], capture_output=True, text=True)
          
          prs = json.loads(pr_data.stdout) if pr_data.returncode == 0 else []
          
          # 2. Analyze which parts of codebase were touched
          changes = {
              "providers": [],
              "commands": [],
              "config": [],
              "core": [],
              "docs": []
          }
          
          for pr in prs:
              for file in pr.get("files", []):
                  if "providers/" in file:
                      changes["providers"].append(pr["title"])
                  elif "commands/" in file:
                      changes["commands"].append(pr["title"])
                  elif "config/" in file:
                      changes["config"].append(pr["title"])
                  elif "mgit/" in file:
                      changes["core"].append(pr["title"])
                  elif ".md" in file:
                      changes["docs"].append(pr["title"])
          
          # 3. Create structured change document
          with open("structured-changes.json", "w") as f:
              json.dump({
                  "pull_requests": prs,
                  "categorized_changes": changes,
                  "version": "$VERSION"
              }, f, indent=2)
              
          # 4. Extract key improvements from PR bodies
          improvements = []
          for pr in prs:
              body = pr.get("body", "")
              if body:
                  # Look for improvement patterns
                  if "fix" in body.lower():
                      improvements.append(f"Fixed: {pr['title']}")
                  elif "add" in body.lower() or "feature" in body.lower():
                      improvements.append(f"Added: {pr['title']}")
                  elif "improve" in body.lower() or "enhance" in body.lower():
                      improvements.append(f"Enhanced: {pr['title']}")
          
          with open("key-improvements.txt", "w") as f:
              f.write("\n".join(improvements))
          EOF
          
          python analyze_changes.py
          
      - name: Generate AI Release Notes with Full Context
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          pip install openai
          
          cat > generate_release_notes.py << 'EOF'
          import openai
          import json
          from pathlib import Path
          
          client = openai.OpenAI()
          
          # Load all context
          codebase_context = Path("codebase-context.md").read_text()
          structured_changes = json.loads(Path("structured-changes.json").read_text())
          key_improvements = Path("key-improvements.txt").read_text()
          
          # Enhanced system prompt with full understanding
          system_prompt = f"""You are a technical writer creating release notes for mgit with a touch of personality.
          
          CODEBASE CONTEXT:
          {codebase_context}
          
          CRITICAL RULES:
          - mgit is ONLY for managing git repositories (clone, pull, list)
          - Never mention CI/CD, pipelines, or automation features
          - Focus on actual repository management improvements
          - Be factual and specific about changes
          - Add ONE subtle 80s reference in the intro or closing (not both)
          - Keep the reference light and professional
          
          GOOD 80s TOUCHES (pick ONE per release):
          - "Taking repository management to 88mph"
          - "Your repositories are ready for prime time"
          - "Power up your git workflow"
          - "The future of repository management is now"
          
          BAD EXAMPLES (avoid these):
          - Heavy movie quotes throughout
          - "Totally tubular" or dated slang
          - Multiple references per section
          """
          
          # User prompt with structured changes
          user_prompt = f"""Generate release notes for mgit {structured_changes['version']}.
          
          CHANGES BY CATEGORY:
          - Provider improvements: {len(structured_changes['categorized_changes']['providers'])} changes
          - Command updates: {len(structured_changes['categorized_changes']['commands'])} changes  
          - Config changes: {len(structured_changes['categorized_changes']['config'])} changes
          - Core updates: {len(structured_changes['categorized_changes']['core'])} changes
          
          KEY IMPROVEMENTS:
          {key_improvements}
          
          PULL REQUESTS:
          {json.dumps(structured_changes['pull_requests'], indent=2)}
          
          Create clear, accurate release notes that explain what changed and why it matters for users managing multiple git repositories.
          """
          
          response = client.chat.completions.create(
              model="gpt-4",
              messages=[
                  {"role": "system", "content": system_prompt},
                  {"role": "user", "content": user_prompt}
              ],
              temperature=0.1,
              max_tokens=1500
          )
          
          release_notes = response.choices[0].message.content
          Path("release-notes.md").write_text(release_notes)
          print(f"Generated {len(release_notes)} characters of release notes")
          EOF
          
          python generate_release_notes.py
          
      - name: Create Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release create "${{ github.event.inputs.version }}" \
            --title "mgit ${{ github.event.inputs.version }}" \
            --notes-file release-notes.md