name: Auto Release on Version Change

on:
  push:
    branches: [ main ]
    paths:
      - 'pyproject.toml'
      - 'mgit/constants.py'

permissions:
  contents: write
  packages: write

jobs:
  check-version:
    name: Check Version Change
    runs-on: ubuntu-latest
    outputs:
      version-changed: ${{ steps.check.outputs.changed }}
      new-version: ${{ steps.check.outputs.version }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 2
        
    - name: Check if version changed
      id: check
      run: |
        # Get current version from pyproject.toml
        CURRENT_VERSION=$(grep -m1 '^version' pyproject.toml | sed 's/.*"\(.*\)".*/\1/')
        
        # Get previous version
        git checkout HEAD~1
        PREVIOUS_VERSION=$(grep -m1 '^version' pyproject.toml | sed 's/.*"\(.*\)".*/\1/' || echo "")
        git checkout -
        
        echo "Current version: $CURRENT_VERSION"
        echo "Previous version: $PREVIOUS_VERSION"
        
        if [ "$CURRENT_VERSION" != "$PREVIOUS_VERSION" ]; then
          echo "changed=true" >> $GITHUB_OUTPUT
          echo "version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "Version changed from $PREVIOUS_VERSION to $CURRENT_VERSION"
        else
          echo "changed=false" >> $GITHUB_OUTPUT
          echo "Version unchanged"
        fi

  generate-release-notes:
    name: Generate Release Notes
    runs-on: ubuntu-latest
    needs: check-version
    if: needs.check-version.outputs.version-changed == 'true'
    outputs:
      release-notes: ${{ steps.generate.outputs.notes }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        
    - name: Generate AI Release Notes
      id: generate
      env:
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        VERSION: ${{ needs.check-version.outputs.new-version }}
      run: |
        # Install OpenAI if API key is available
        if [ -n "$OPENAI_API_KEY" ]; then
          pip install openai
        fi
        
        # Extract changes from CHANGELOG.md
        echo "Extracting changes from CHANGELOG.md..."
        cat > extract_changes.py << 'EOF'
        import re
        import sys
        
        version = "$VERSION"
        
        # Read CHANGELOG.md
        try:
            with open('CHANGELOG.md', 'r') as f:
                content = f.read()
        except FileNotFoundError:
            print("No CHANGELOG.md found")
            sys.exit(0)
        
        # Extract section for this version
        pattern = rf'## \[?{re.escape(version)}\]?.*?\n(.*?)(?=\n## |\Z)'
        match = re.search(pattern, content, re.DOTALL)
        
        if match:
            changes = match.group(1).strip()
            with open('version_changes.txt', 'w') as f:
                f.write(changes)
            print(f"Extracted {len(changes)} characters of changes")
        else:
            print(f"No changes found for version {version}")
            # Fall back to recent commits
            import subprocess
            commits = subprocess.run(['git', 'log', '--oneline', '-n', '20'], 
                                   capture_output=True, text=True)
            with open('version_changes.txt', 'w') as f:
                f.write("Recent commits:\n" + commits.stdout)
        EOF
        
        python extract_changes.py
        
        # Generate release notes with AI or fallback
        if [ -n "$OPENAI_API_KEY" ]; then
          echo "Generating AI release notes..."
          cat > generate_notes.py << 'EOF'
        import openai
        import os
        
        client = openai.OpenAI()
        
        # Read changes
        with open('version_changes.txt', 'r') as f:
            changes = f.read()
        
        # Read README for context
        with open('README.md', 'r') as f:
            readme_lines = f.readlines()[:50]
            project_context = ''.join([line for line in readme_lines if line.strip()])
        
        prompt = f"""Generate concise GitHub release notes for mgit version $VERSION.
        
        Project: mgit - A multi-provider Git repository management CLI tool.
        Context: {project_context[:500]}
        
        Changes:
        {changes}
        
        Create professional release notes with:
        1. A brief summary of what this release includes
        2. Key improvements or features (if any)
        3. Bug fixes (if any)
        4. One-line installation command
        
        Keep it concise and focused on what matters to users.
        """
        
        response = client.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": "You are a technical writer creating GitHub release notes."},
                {"role": "user", "content": prompt}
            ],
            temperature=0.3,
            max_tokens=500
        )
        
        notes = response.choices[0].message.content
        
        # Save to file
        with open('release_notes.md', 'w') as f:
            f.write(f"# mgit v$VERSION\n\n")
            f.write(notes)
        EOF
          
          python generate_notes.py || echo "AI generation failed"
        fi
        
        # Fallback if no AI or if it failed
        if [ ! -f release_notes.md ]; then
          echo "Creating fallback release notes..."
          cat > release_notes.md << EOF
        # mgit v$VERSION
        
        ## Changes in this release:
        
        $(cat version_changes.txt)
        
        ## Installation
        
        \`\`\`bash
        pip install mgit==$VERSION
        \`\`\`
        EOF
        fi
        
        # Output to GitHub
        {
          echo 'notes<<EOF'
          cat release_notes.md
          echo 'EOF'
        } >> $GITHUB_OUTPUT

  build-and-release:
    name: Build and Release
    runs-on: ubuntu-latest
    needs: [check-version, generate-release-notes]
    if: needs.check-version.outputs.version-changed == 'true'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        
    - name: Install Poetry
      run: |
        curl -sSL https://install.python-poetry.org | python3 -
        echo "$HOME/.local/bin" >> $GITHUB_PATH
        
    - name: Build packages
      run: |
        poetry build
        
    - name: Create and push tag
      env:
        VERSION: ${{ needs.check-version.outputs.new-version }}
      run: |
        git config user.name github-actions
        git config user.email github-actions@github.com
        git tag -a "v$VERSION" -m "Release v$VERSION"
        git push origin "v$VERSION"
        
    - name: Create GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: v${{ needs.check-version.outputs.new-version }}
        name: Release v${{ needs.check-version.outputs.new-version }}
        body: ${{ needs.generate-release-notes.outputs.release-notes }}
        files: |
          dist/*.whl
          dist/*.tar.gz
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Build Docker image
      uses: docker/setup-buildx-action@v3
      
    - name: Log in to GitHub Container Registry
      uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: |
          ghcr.io/${{ github.repository }}:latest
          ghcr.io/${{ github.repository }}:${{ needs.check-version.outputs.new-version }}
        platforms: linux/amd64,linux/arm64
        cache-from: type=gha
        cache-to: type=gha,mode=max

  publish-pypi:
    name: Publish to PyPI
    runs-on: ubuntu-latest
    needs: [check-version, build-and-release]
    if: needs.check-version.outputs.version-changed == 'true'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        
    - name: Install Poetry
      run: |
        curl -sSL https://install.python-poetry.org | python3 -
        echo "$HOME/.local/bin" >> $GITHUB_PATH
        
    - name: Build packages
      run: |
        poetry build
        
    - name: Publish to PyPI
      env:
        POETRY_PYPI_TOKEN_PYPI: ${{ secrets.PYPI_API_TOKEN }}
      run: |
        poetry publish --skip-existing